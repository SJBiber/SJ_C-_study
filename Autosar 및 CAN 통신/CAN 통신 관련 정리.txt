CAN 통신
	- CAN 통신이란 ?
		- 차량 내에서 호스트 컴푸터 없이 ECU 장치들이 서로 통신하기 위해 설꼐된 메시지 기반 통신규격
		- Non Host 버스 방식의 메시지 기반 네트워크 프로토콜
		
	- CAN 통신 특징
		- 최대 1Mbps 데이터 전송 속도로 실시간 전송 가능
		- 장거리 통신 (40Kbps에서 최대 1KM 통신 가능)
		- 경제적이며 노드 증감 및 네트워크 구성에 유연
		- RX485처럼 차동 신호 사용으로 노이즈에 강하며 장거리 전송에 적당
		- 멀티 마스터 통신
		- 메시지 우선 순위 지정으로 노드간 통신 중재 (메시지 충돌 발생시 중재가 가능)
		- ID 필터링을 통한 멀티캐스트 통신
		- 탁월한 에러 처리와 제한 기능 (결함 노드 버스 연결 단절)
	
	- CAN 응용
		파워 트레인 파트		: 엔진 관리 , 미끄럼 방지 브레이크 , 기어제어 , 활성 서스팬션 등과 같은 ECU 간 통신
		차체(샤시)제어 파트	: 계기판 , 조명 , 에어컨 , 창문 , 도어잠금 , 에어백 , 좌석 벨트 등과 같은 장치 제어
		정보 오락				: 멀티미디어 디스플레이 , 오디오 , 이터넷 , 주차보조시스템 등과 같은 장치 제어
		
	- OSI 7계층으로 본 CAN 통신
		-> CAN은 OSI 7계층에서 물리계층과 데이터 링크 계층만 사용됨
		
		데이터 링크 계층에서 -> 물리계층 구조도 정리
		[ 상위 계층 (Application Layer) ]
                        │
                        ▼
       ┌──────────────────────────────────────┐
       │       LLC (Logical Link Control)     │
       │  - 메시지 필터링/식별자 해석          	  │
       │  - 에러 상태 전달                      │
       │  - 데이터 흐름 관리                  	  │
       └──────────────────────────────────────┘
                        │
                        ▼
       ┌──────────────────────────────────────┐
       │        MAC (Medium Access Control)   │
       │  - Arbitration (중재)             	  │
       │  - CRC, ACK, Error Frame 처리      	  │
       │  - Bit Stuffing, 프레임 구성       	  │
       └──────────────────────────────────────┘
                        │
                        ▼
       ┌──────────────────────────────────────┐
       │        Physical Layer (PHY 포함)   	  │
       │  - PMA, PMD 등 신호 인코딩 및 송수신 	  │
       └──────────────────────────────────────┘
                        │
                        ▼
             [ Physical Medium (CAN Bus) ]
		
		물리계층 구조도
		┌────────────────────────────────────────────┐
		│                 MAC Layer                  │ ← 데이터 프레임 송수신
		└────────────────────────────────────────────┘
							│
							▼
		┌────────────────────────────────────────────┐
		│          PCS (Physical Coding Sublayer)    │ ← 인코딩 (예: 4B5B), 에러 감지
		└────────────────────────────────────────────┘
							│
							▼
		┌────────────────────────────────────────────┐
		│      PMA (Physical Medium Attachment)       │ ← SerDes, CDR, 동기화, 신호 정렬
		└────────────────────────────────────────────┘
							│
							▼
		┌────────────────────────────────────────────┐
		│     PMD (Physical Medium Dependent)         │ ← 실제 전기/광학 신호 생성 및 감지
		└────────────────────────────────────────────┘
							│
							▼
		┌────────────────────────────────────────────┐
		│         Physical Medium (케이블, 커넥터)     │ ← UTP, STP, 광섬유 등
		└────────────────────────────────────────────┘	
			-> CAN Controller
				- Physical Coding Sub-Layer(PCS)	- 물리 계층
					*정의 : PCS는 MAC 계층과 PMA 사이에서 , 디지털 데이터를 물리 계층에 맞는 형식으로 인코딩 / 디코딩 하는 서브 계층입니다.
					*주요 역할 : 	데이터를 신호 전송에 적합한 비트 패턴으로 인코딩(라인 인코딩)
								데이터 스트림에서 프레임의 시작과 끝을 식별(동기화)
								비트 스트림에서 클럭을 재정렬하거나 정합(클럭 보정)
								인코딩 중에 오류 감지 및 검출
								다중 Lane에서 Lane정렬(PCS Lane Alignment)
								유휴 상태 표현 , 제어 프레임 구분 등
			-> CAN tramsceiver
				- Physical Media Attachment(PMA)- 물리 계층
					*정의 : PMD와 상위 계층(PCS 등)을 연결하는 인터페이스 계층
					*주요 역할 : 	직렬 / 병렬 변환
								신호 클럭 복원
								동기화 및 인터페이싱
								전기적 손실 보정
					*간단하게 정리 : 신호를 정제 및 동기화
				- Physical Media Dependent(PMD)	- 물리 계층
					*정의 : 매체 (케이블 , 광섬유 등)와의 실제적인 전기적/광학적 신호 송수신을 담당하는 계층
					*주요 역할 : 	전기적 / 광학적 신호를 생성 및 감지
								송신 시 : 디지털 신호 -> 전기/광학 신호로 변환
								수신 시 : 전기/광학 신호 -> 디지털 신호로 복조
								매체 종류에 따라 회로 구조가 다름 (ex : 동축 케이블 , UTP , 광섬유 , 단일쌍 이더넷 등)
					*간단하게 정리 : 실제 신호를 생성 및 감지하는 역할
	
		데이터 링크 계층 구조도
       ┌──────────────────────────────────────┐
       │       LLC (Logical Link Control)     │
       │  - 메시지 필터링/식별자 해석     	      │
       │  - 에러 상태 전달               	      │
       │  - 데이터 흐름 관리            	      │
       └──────────────────────────────────────┘
                        │
                        ▼
       ┌──────────────────────────────────────┐
       │        MAC (Medium Access Control)   │
       │  - Arbitration (중재)              	  │
       │  - CRC, ACK, Error Frame 처리      	  │
       │  - Bit Stuffing, 프레임 구성      	  │
       └──────────────────────────────────────┘
			-> CAN Controller
				- Logic Link Control(LLC)	- 데이터 링크 계층
					*정의 : 상위 계층과 MAC 계층 간의 인터페이스 역할 , 데이터 흐름 제어 및 오류 통보 등 관리적인 기능 수행
					*주요 역할 : 	프레임 필터링 및 수신 메시지 전달 판단
								에러 상태 및 통계 보고
								프레임의 종류 구분
								전송 요청 큐 관리
				- Media Access Control(MAC)	- 데이터 링크 계층
					*정의 : CAN 버스를 어떤 노드가 사용할지 결정하는 기능을 수행
					*주요 역할 : 	메시지 우선순위 기반 Arbitration (중재) / 식별자(ID)가 낮을수록 우선순위가 높음
								프레임 구조 정의 및 송수신 처리
								에러 검출 및 자동 재전송
								Bus 상태 감지

CAN 프레임
	- data 프레임	: 데이터 전송을 위한 프레임
	- Remote 프레임	: 노드가 데이터 프레임으로 부터 전송될수있도록 연결해주는 프레임
	- Error 프레임	: 노드가 에러를 검출하게될시 주변 노드들에게 알림을 전송하는 프레임
	- Overload 프레임: 노드에서 과부하 제어를 수행하는 프레임
					
	데이터 프레임
		*RTP(Remote transmission Request) 	: 0일때 데이터 프레임 , 1일때 원격 프레임
		*IDE(IDentifier Extension) 			: 0일때 표준(11bit ID) 프레임 , 1일때 확장(29bit ID) 프레임
		*DLC(Data Length Code)				: 0~8바이트 크기 나타냄
		*SRR(Substitute Remote Request)		: 원격 프레임시 1개의 열성 비트로 대체
		- 표준형 데이터 프레임
		  SOF (START OF Frame)	 : 1비트
		  ID					 : 11비트	+
		  RTR (데이터 프레임 : 0)	 : 1비트		+ 총 12비트
		  IDE (표준 : 0)			 : 1비트		+
		  r0					 : 1비트		+	
		  DLC					 : 4비트		+ 총 6비트
		  Data					 : 0~8바이트	+ 총 8*N 비트
		  CRC 					 : 15비트	+ CRC 구분 포함 총 16비트
		  ACK					 : 1비트		+ ACK 구분 포함 총 2비트
		  EOF					 : 7비트		+ 총 7비트
		  IFS or Overload Frame	 : 3비트
		  
		- 확장형 데이터 프레임
		  SOF (START OF Frame)	 : 1비트
		  ID					 : 11비트	+
		  RTR (데이터 프레임 : 0)	 : 1비트		+ 
		  IDE (확장 : 1)			 : 1비트		+
		  Extended ID			 : 18비트	+ 총 32비트
		  r1					 : 1비트		+
		  r0					 : 1비트		+	
		  DLC					 : 4비트		+ 총 6비트
		  CRC 					 : 15비트	+ CRC 구분 포함 총 16비트
		  ACK					 : 1비트		+ ACK 구분 포함 총 2비트
		  EOF					 : 7비트		+ 총 7비트
		  IFS or Overload Frame	 : 3비트
	
	원격 프레임 ( DLC와 CRC 사이에 데이터가 없음 : 데이터를 요청하는 프레임이라 데이터를 넣어서 보낼 필요가 없기 떄문 )
		- 표준형 원격 프레임
		  SOF (START OF Frame)	 : 1비트
		  ID					 : 11비트	+
		  RTR (원격 프레임 : 1)	 : 1비트		+ 총 12비트
		  IDE (표준 : 0)			 : 1비트		+
		  r0					 : 1비트		+	
		  DLC					 : 4비트		+ 총 6비트
		  Data					 : 0~8바이트	+ 총 8*N 비트
		  CRC 					 : 15비트	+ CRC 구분 포함 총 16비트
		  ACK					 : 1비트		+ ACK 구분 포함 총 2비트
		  EOF					 : 7비트		+ 총 7비트
		  IFS or Overload Frame	 : 3비트	

		- 확장형 원격 프레임
		  SOF (START OF Frame)	 : 1비트
		  ID					 : 11비트	+
		  RTR (원격 프레임 : 1)	 : 1비트		+ 
		  IDE (확장 : 1)			 : 1비트		+
		  Extended ID			 : 18비트	+ 총 32비트
		  r1					 : 1비트		+
		  r0					 : 1비트		+	
		  DLC					 : 4비트		+ 총 6비트
		  CRC 					 : 15비트	+ CRC 구분 포함 총 16비트
		  ACK					 : 1비트		+ ACK 구분 포함 총 2비트
		  EOF					 : 7비트		+ 총 7비트
		  IFS or Overload Frame	 : 3비트
	
	에러 프레임 
	 - CAN 통신은 에러카운트를 집계함 / 자기 상태에 따라 에러 카운트 별로 많으면 수동 에러 프레임 , 적다면 능동 에러 프레임을 사용
		- 능동 / 수동 에러 프레임
		  Error Flag (primary)		: 6 비트
		  Error Flag (secondary)	: 0~6비트
		  Error Delimiter			: 8 비트
	
	과부하 프레임
		- 오버로드 프레임
		  Overload Flag			: 6 비트
		  Overload Delimiter	: 8 비트
	
	* CAN 통신에서 에러 프레임과 과부하 프레임의 구별법
		-> 데이터 프레임 , 리모트 프레임을 전송하는 중에 에러가 발생할 경우 그 즉시 에러 프레임이 전송 됨
		-> 과부하 프레임은 한 프레임이 전송이 완료된 이후에 과부하 프레임이 전송 됨
		* 즉 에러 , 과부하 프레임을 구별하는 법은 해당 프레임의 발생 시점으로 구분한다.
		
CAN 통신 동기화
	CAN 통신에서 동기화는 왜 사용되는가 ?
		CAN은 클럭 신호 없이 비동기식 NRZ(bit-level) 방식으로 데이터를 전송합니다.
		따라선 송신기와 수신기 간 클럭 드리프트 , 버스 지연 , 오실레이터 오차 등을 
		지속적으로 보정해야 네트워크 전체가 동일한 타이밍 기준으로 작동할 수 있음
	왜 중요한가 ?
		CAN의 비동기 전송 환경에서 타이밍 정합성이 없으면 중재가 실패할 수 있으며 , 프레임 오류 발생률이 증가
		하드 / 리싱크를 통한 계속적 타이밍 보정은 데이터 신뢰성 , 중재 정확성 , 노드간 타이밍 일치 보장에 매우 중요!
		
	비트 시간 구조
		CAN 표준은 1비트(Time)를 아래처럼 시간 단위(Time Quantum : tQ) 기반으로 네 개의 세그먼트로 나눔
		해당 구조 덕분에 오차를 탐지하고 보정 가능함
		- 동기화 세그먼트 			/ Sync_Seg(1 tQ)			: 동기화 시그널(수신 타이밍 기준)
		- 전파 시간 세그먼트 		/ Prop_Seg					: 버스 전파 지연과 내부 회로 지연 보상
		- 위상 버퍼 세그먼트 1 & 2	/ Phase_Seg1 & Phase_Seg2 	: 위상 조정용 버퍼
	
	- 하드 동기화 (Hard Synchronization)
		Start of Frame(SOF) 직후 Recessive -> Dominant 전이 시 발생 / 열성(1)에서 우성(0)으로 변화시 발생
		비트 타임을 즉시 Resync_Seg 기준으로 비트 타이밍 카운터를 리셋
		모든 노드는 이 순간부터 동일한 기준으로 동기화
	
	- 소프트 동기화 / 재동기화 (Resynchronization)
		프레임 중간에서도 각 Recessive -> Dominent 전이마다 발생 가능 / 즉 열성(1)에서 우성(0)으로 변화되는 모든 시점
		발생 시 위상 오류 측정 -> 비트 샘플링 지점 보정
			-> 위상 오류 양수 : Phase_Seg1 증가
			-> 위상 오류 음수 : Phase_Seg2 감소
		단. 보정 폭은 Synchronization Jump Width(SJW) 이하로 제한됨
	
	동기화 흐름 그림
	┌──────────────────────────────────────────────┐
	│           Start-of-Frame (SOF)               │
	│ (Recessive→Dominant 전이 → Hard Sync)     	   │
	└──────────────────────────────────────────────┘
						│
		비트 타임 타이머 리셋 → Sync_Seg 시작
						│
	┌──────────────────────────────────────────────┐
	│     Prop_Seg (전파 지연 보상)              	   │
	├──────────────────────────────────────────────┤
	│     Phase_Seg1  ← 조정 가능 (리싱크 시)    	   │
	│        │                                     │
	│  Sample Point 위치 (Phase1/Phase2 경계)    	   │
	│        ↓                                     │
	│     Phase_Seg2  ← 조정 가능 (리싱크 시)     	   │
	└──────────────────────────────────────────────┘
						│
   Recessive→Dominant 발생? → Yes → Resynchronization 적용
                     → No → 다음 비트 진행
					 
	비트 스터핑이란 ?
		CAN은 NRZ(Non Return to Zero) 방식으로 신호를 전송하기 때문에 , 동일 레벨(0 or 1)이 연속될 경우 클럭 동기화에 어려움이 발생
		이를 해결하기 위해 동일한 비트가 5개 연속될 경우 , 자동으로 반대 극성의 비트를 삽입
		삽입된 비트는 전송 측에서 자동 생성되고 , 수신 측에서 자동 삭제 됨
		ex)	111111 패턴이 나올 때 111100 1 로 전송
			000000 패턴이 나올 때 000001 0 로 전송 
	왜 필요한가 ? -> 동기화 확보 목적
		삽입된 비트는 신호 전환을 더 자주 만들어 주기 때문에 ,수신기 측 클럭 드리프트 포정과 재동기화가 가능
		SOF(Start-of-Frame) 이후 부터 CRC 필드 전까지 stuffing이 적용되며 , SOF의 열성 -> 우성 전이가 Hard Sync를 트리거 함
		이후 전이가 감지될 때마다 Phase 세그먼드 조정으로 재동기화가 이루어짐
		
	비트 스터핑 동작 구조
	[ 전송기 (Transmitter) ]
	원본 데이터 스트림
			│
		비트 체크: 연속 5개 동일?
			├─ Yes → Stuff bit 삽입 (반대 극성)
			└─ No  → 그대로 전송
			↓
	[ 비트+Stuff 스트림 ] → NRZ 인코딩 → 버스 송출
	
	[ 수신기 (Receiver) ]
	수신된 비트 스트림
			│
		연속 5비트 이후 6번째 비트 검사
			├─ Stuff bit 감지 → 삭제
			└─ 잘못된 경우 → 에러 프레임
			↓
	원본 데이터 복원 → 디코딩 → 상위 계층 전달

	비트 스터핑의 단점과 한계
		* 스터프 비트가 많아질수록 프레임 길이가 비정상적으로 늘어날 수 있고 , 메시지 전송 지연이 발생
		실제 CAN 프레임에서 Worst-Case 스터핑으로는 최대 24비트 추가 가능 , 전체 132 비트 길이까지 증가
		* 데이터 필드 일부 연구에서는 Miller Line Encoding이나 Zero-Stuff bit와 같은 대체 인코딩 기법을 제안하여 스터핑을 줄이는 연구도 있음
	
	중재 (ID Arbitration)란 ?
		CAN 버스는 다수의 노드가 동시에 데이터 전송을 시도하는 멀티 마스터 방식
		동시에 전송 요청이 발생하면 , 메시지 식별자(ID)의 우선순위에 따라 송신 노드를 결정
		ID 값이 낮을 수록 우선순위가 높고 , 가장 낮은 ID가 전송을 계속함
		소프트웨어나 중앙 컨트롤러가 아닌, 하드웨어 수순의 비파괴적 비트 단위 중재 방식

	Arbitration Field 구정
		SOF 비트 후에 Identifier(11/29 비트) 및 RTR 비트가 이어지는데
		이 세 비트 부분이 Arbitration field를 구성함 / 해당 field에서 중재를 시도함
	
	Bitwise Arbitration
		각 노드는 각 비트마다 현재 자신의 송신 비트와 버스 상태를 비교
			- 자신이 열성(1)을 보냈지만 , 버스에서 우성(0)을 감지하면 해당 노드는 즉시 전송 중단 -> 다른 노드가 우선권을 얻게됨
			- 반면 자신의 비트가 우성(0)이고 ,버스도 0이면 계속 전송됨
	
	비파괴적 중재(Non-Destructive Arbitration)
		중재에서 패한 메시지는 전송 실패 없이 자동으로 재시도가 가능
		높은 우선순위 메시지는 끊김없이 전송되고, 낮은 우선순위 메시지는 버스가 확보되는 즉시 다시 경합
		
	우선순위 결정 기준!
		- ID가 낮을 수록(ex : 0x000 > 0x100) 우선순위 높음 -> 먼저 전송 권한을 휙득함
		- 동일한 식별자를 가진 메시지가 동시에 전송될 경우 , RTR 비트가 결정적인 요소가 됨
			-> 데이터 프레임(RTR=0)이 원격 프레임(RTR=1)보다 우선권을 가지게 됨
	
	중재 구성도
	[ 여러 노드 A, B, C — 동시에 송신 요청 ]
            │
            ▼
	[ SOF 전송 (Dominant) ]
				│
				▼
	[ Arbitration Field (ID + RTR) 전송 ]
				│
				▼ Bit‑by‑Bit 비교 시작
	┌────────────────────────────────────────────┐
	│ 노드 A/B/C 각 비트 송신                     	 │
	└────────────────────────────────────────────┘
				│
				▼
	For each bit:
	 노드 i 가 Recessive 전송(1)했는데,
	 버스가 Dominant(0)면 → 노드 i 중재 패배 → 수신 모드로 전환
	 계속 Dominant(0)이면 → 우선권 유지
				│
				▼
	마지막 비트까지 생존한 노드 → 전송 이어감
				│
				▼
	나머지 노드들은 bus idle 후 자동 재경합